● 根据搜索结果，我为你整理了适合Linux应用工程师转型驱动工程师的高Star GitHub项目。以下是我按分类整理的项目列表：

  🎯 教程和学习资源类

  1. The Linux Kernel Module Programming Guide ⭐

  - GitHub: sysprog21/lkmpg
  - Star数: 2K+
  - 转型价值:
    - 最权威的内核模块编程入门指南
    - 从基础概念到高级实践的完整路径
    - 包含大量实例代码和详细解释
    - 适合有Linux应用经验的工程师快速理解内核架构

  2. Linux_Driver_Tutorial ⭐

  - GitHub: Johannes4Linux/Linux_Driver_Tutorial
  - Star数: 632+
  - 转型价值:
    - 2024年最新的驱动开发教程
    - 实践导向，从简单到复杂的递进式学习
    - 涵盖现代Linux驱动开发的核心概念

  🔧 实践项目类

  3. Linux-Device-Driver ⭐

  - GitHub: d0u9/Linux-Device-Driver
  - Star数: 516+
  - 转型价值:
    - 基于经典《Linux Device Drivers 3》的高级示例
    - 包含QEMU虚拟化环境，便于实验
    - 涵盖PCI、USB、串口等多种设备类型
    - 作者正在编写新的驱动开发书籍

  4. linux-driver-examples ⭐

  - GitHub: rrmhearts/linux-driver-examples
  - Star数: 400+
  - 转型价值:
    - 专注于字符驱动、misc驱动、平台驱动、I2C驱动
    - 提供清晰的分类和详细注释
    - 适合理解和学习不同类型的驱动架构

  🏗️ 嵌入式系统类

  5. Buildroot ⭐

  - GitHub: buildroot/buildroot
  - Star数: 3.2K+
  - 转型价值:
    - 嵌入式Linux系统构建工具
    - 理解嵌入式系统启动流程和驱动加载机制
    - 大量设备驱动配置实例
    - 工业界广泛使用的成熟项目

  6. Zephyr Project ⭐

  - GitHub: zephyrproject-rtos/zephyr
  - Star数: 9K+
  - 转型价值:
    - 实时操作系统内核开发
    - 支持800+开发板，驱动资源丰富
    - 现代化的驱动框架和开发流程
    - IoT和嵌入式领域的热门技术

  🔍 内核开发和调试工具类

  7. Elixir Cross Referencer (通过Bootlin)

  - 转型价值:
    - Linux内核源码浏览和理解工具
    - 学习内核代码结构和API调用关系
    - 提高阅读和理解内核代码的效率

  📚 补充资源

  8. Linux Device Drivers, 3rd Edition (LDD3)

  - 在线免费: Bootlin提供PDF版本
  - 转型价值:
    - 驱动开发经典教材
    - 系统性的知识体系
    - 大量实际案例和最佳实践

  🎓 转型建议学习路径

  1. 理论基础: 先学习LKMPG，理解内核模块基本概念
  2. 实践入门: 跟随Linux_Driver_Tutorial进行动手实践
  3. 深入探索: 通过Linux-Device-Driver项目学习复杂驱动
  4. 嵌入式扩展: 学习Buildroot和Zephyr，了解嵌入式驱动开发
  5. 工具掌握: 使用Elixir等工具提高代码阅读效率

● 这些项目都满足你的要求（Star数 > 1K），并且特别适合有Linux应用开发经验的工程师转型驱动开发。它们涵盖了从理论学习到实际项目实践
  的完整路径，能够帮助你系统地掌握Linux驱动开发的核心技能。

> 有哪些经典高star项目巩固我的linux应用工程师的技术以及基础知识，为进军内核驱动打下坚实基础的。

● exa - web_search_exa (MCP)(query: "\"linux application development\" github stars:\">5000\" system programming c c++")
  ⎿  {                                                                                                                                
       "requestId": "443c2bf39fd69a50b66c8edbddf507e8",
       "autopromptString": "\"linux application development\" github stars:\">5000\" system programming c c++",
     … +319 lines (ctrl+o to expand)

● exa - web_search_exa (MCP)(query: "经典Linux C/C++开源项目 github stars:\">10000\" system programming \"high performance\"")
  ⎿  {
       "requestId": "00c64965e6152692d0b7c66cd0b9e1cc",
       "autopromptString": "经典Linux C/C++开源项目 github stars:\">10000\" system programming \"high performance\"",
     … +356 lines (ctrl+o to expand)

● exa - web_search_exa (MCP)(query: "redis nginx apache linux foundation \"github stars:\">10000\" system programming")
  ⎿  {
       "requestId": "405441c2fb31a3a4b5e4e81da8cff9cc",
       "autopromptString": "redis nginx apache linux foundation \"github stars:\">10000\" system programming",
     … +362 lines (ctrl+o to expand)

● 根据搜索结果，我为你整理了适合Linux应用工程师巩固基础、为转型驱动开发打下坚实基础的经典高Star项目：

  🔥 网络与服务器开发类

  1. NGINX ⭐⭐⭐

  - Star数: 10K+
  - 转型价值:
    - 理解高性能网络编程和事件驱动架构
    - 学习异步I/O、多进程/多线程设计模式
    - 掌握系统调用优化和内存管理技术
    - 为网络驱动开发打下坚实基础

  2. Apache APISIX ⭐⭐⭐

  - Star数: 11K+
  - 转型价值:
    - 学习API网关和代理服务器架构
    - 理解插件系统和动态加载机制
    - 掌握高并发网络编程技术
    - 了解现代网络服务的核心原理

  3. OpenResty ⭐⭐⭐

  - Star数: 15K+
  - 转型价值:
    - 基于NGINX+Lua的高性能Web平台
    - 学习模块化设计和扩展机制
    - 理解动态脚本语言集成
    - 掌握高性能系统架构设计

  🚀 高性能系统编程类

  4. Envoy Proxy ⭐⭐⭐

  - Star数: 26K+
  - 转型价值:
    - C++高性能网络编程最佳实践
    - 理解异步编程和事件循环
    - 学习内存管理和资源调度
    - 掌握系统级性能优化技术

  5. Seastar Framework ⭐⭐⭐

  - Star数: 8K+
  - 转型价值:
    - 共享 nothing架构设计
    - 高性能异步I/O框架
    - 多核并发编程模式
    - 现代C++编程范式和内存管理

  6. DPDK (Data Plane Development Kit) ⭐⭐⭐

  - Star数: 3K+
  - 转型价值:
    - 用户态网络包处理框架
    - 绕过内核网络栈的高性能方案
    - 理解硬件直接访问机制
    - 为内核驱动开发提供重要对比和参考

  💾 存储和内存管理类

  7. Redis ⭐⭐⭐

  - Star数: 65K+
  - 转型价值:
    - 内存数据库设计和优化
    - 高效内存管理算法
    - 异步事件处理机制
    - 理解系统调用和文件系统交互

  8. ** jemalloc** ⭐⭐⭐

  - Star数: 8K+
  - 转型价值:
    - 高性能内存分配器实现
    - 理解内存碎片和优化策略
    - 学习系统级内存管理技术
    - 掌握底层内存操作机制

  📊 数据库和大数据类

  9. StarRocks ⭐⭐⭐

  - Star数: 10K+
  - 转型价值:
    - 高性能查询引擎设计
    - 向量化计算和SIMD优化
    - 内存管理和缓存策略
    - 理解大规模数据处理架构

  🔧 系统工具和开发框架类

  10. fio (Flexible I/O Tester) ⭐⭐⭐

  - Star数: 2K+
  - 转型价值:
    - 深入理解Linux I/O子系统
    - 异步I/O测试和性能分析
    - 理解块设备和文件系统交互
    - 掌握系统调用和内核接口使用

  💡 学习路径建议

  1. 网络基础: 从NGINX开始，理解网络编程和系统架构
  2. 高性能编程: 学习Seastar和Envoy，掌握现代C++并发模式
  3. 内存管理: 通过Redis和jemalloc理解内存优化技术
  4. 系统接口: 学习fio，深入理解Linux I/O子系统
  5. 底层原理: 研究DPDK，理解用户态vs内核态的权衡

  这些项目不仅Star数高，而且都是工业界广泛使用的成熟项目，能帮助你建立扎实的系统编程基础，为后续的内核驱动开发提供坚实的技术支撑。

> 主要开发语言是C的，不考虑使用C++的项目

● exa - web_search_exa (MCP)(query: "linux c projects github stars:\">5000\" system programming kernel development \"high performance\"")
  ⎿  {                                                                                                                                
       "requestId": "b79be62f3c08621018a28726bf363737",
       "autopromptString": "linux c projects github stars:\">5000\" system programming kernel development \"high performance\"",
     … +321 lines (ctrl+o to expand)

● exa - web_search_exa (MCP)(query: "github.com/torvalds/linux OR \"linux kernel\" OR \"system programming\" \"github stars:\">10000\"
                             C language")
  ⎿ {
      "requestId": "e2bee22da3c729e02acd66d72b98b145",
      "autopromptString": "github.com/torvalds/linux OR \"linux kernel\" OR \"system programming\" \"github stars:\">10000\" C la
    … +345 lines (ctrl+o to expand)


● exa - web_search_exa (MCP)(query: "nginx redis sqlite curl \"github stars:\">5000\" C language linux programming")
  ⎿  Error: fetch failed

● 基于搜索结果，我为你重新整理了主要以C语言为主的经典高Star Linux项目，这些项目将为你的驱动开发转型打下坚实基础：

  🐧 内核与系统级编程类

  1. Linux Kernel (torvalds/linux) ⭐⭐⭐⭐

  - Star数: 205K+
  - 主要语言: C (99%+) + 少量汇编
  - 转型价值:
    - 核心驱动开发基础: 理解内核架构、模块系统、设备模型
    - 系统调用机制: 深入理解sysfs、procfs、字符设备、块设备
    - 内存管理: 掌握kmalloc、slab分配器、页面管理
    - 并发与同步: 学习锁机制、RCU、工作队列
    - 实际驱动案例: 学习drivers/目录下的各种设备驱动实现

  2. liburing (io_uring library) ⭐⭐⭐

  - Star数: 3K+
  - 主要语言: C
  - 转型价值:
    - 现代异步I/O: 理解Linux最新的高性能I/O接口
    - 内核-用户态接口: 掌握内核与用户空间通信机制
    - 性能优化: 学习零拷贝、批量操作等优化技术
    - 底层系统调用: 理解epoll、poll、select的演进

  3. QEMU ⭐⭐⭐

  - Star数: 8K+
  - 主要语言: C + 少量汇编
  - 转型价值:
    - 虚拟化技术: 理解设备仿真和虚拟硬件抽象
    - 驱动测试环境: 为驱动开发提供安全测试平台
    - 硬件模拟: 学习PCI、USB、网络设备的工作原理
    - 系统架构: 深入理解计算机体系结构

  🌐 网络与高性能I/O类

  4. NGINX ⭐⭐⭐

  - Star数: 10K+
  - 主要语言: C
  - 转型价值:
    - 事件驱动编程: 学习epoll、kqueue等高性能网络模型
    - 多进程架构: 理解master-worker进程模式和IPC
    - 内存管理: 掌握内存池、缓冲区管理技术
    - 模块化设计: 学习插件系统和动态加载机制
    - 系统调用优化: 理解网络编程中的系统调用使用

  5. DPDK (Data Plane Development Kit) ⭐⭐⭐

  - Star数: 3K+
  - 主要语言: C
  - 转型价值:
    - 用户态网络处理: 绕过内核的高性能网络方案
    - 硬件直接访问: 学习DMA、内存映射、中断处理
    - 驱动开发对比: 理解内核驱动vs用户态方案的权衡
    - 性能优化: 掌握NUMA感知、CPU亲和性等优化技术

  🗄️ 存储与文件系统类

  6. SQLite ⭐⭐⭐

  - Star数: 10K+
  - 主要语言: C
  - 转型价值:
    - 文件系统设计: 理解VFS接口、文件操作、缓存机制
    - B树存储结构: 学习数据库索引和磁盘存储原理
    - 事务处理: 掌握ACID、锁机制、并发控制
    - 跨平台兼容: 理解不同架构的适配策略

  🔧 系统工具与库类

  7. fio (Flexible I/O Tester) ⭐⭐⭐

  - Star数: 2K+
  - 主要语言: C
  - 转型价值:
    - I/O子系统测试: 深入理解块设备、文件系统性能测试
    - 异步I/O编程: 学习io_uring、AIO等现代I/O接口
    - 性能分析工具: 掌握系统性能测试和瓶颈分析方法
    - 设备驱动调试: 为驱动开发提供专业测试手段

  📚 基础库与框架类

  8. musl libc ⭐⭐⭐

  - Star数: 3K+
  - 主要语言: C
  - 转型价值:
    - 系统调用接口: 深入理解Linux系统调用实现
    - C标准库: 掌握标准库设计和实现原理
    - 汇编与C接口: 学习底层汇编优化和系统调用约定
    - 启动和链接: 理解程序加载、动态链接过程

  🎯 学习路径建议

  第一阶段：基础巩固 (1-2个月)

  1. SQLite: 学习文件系统和存储原理
  2. NGINX: 掌握网络编程和事件驱动
  3. musl libc: 理解系统调用和C库设计

  第二阶段：系统深入 (2-3个月)

  4. Linux Kernel: 直接研读内核源码，理解驱动框架
  5. liburing: 学习现代异步I/O和内核接口
  6. fio: 掌握I/O测试和性能分析

  第三阶段：驱动实践 (3-4个月)

  7. QEMU环境: 搭建驱动开发和测试环境
  8. DPDK对比: 理解高性能网络的不同实现方案
  9. 简单驱动: 从字符设备、块设备开始实践

  💡 驱动开发关键收获

  通过这些项目，你将获得：
  - 扎实的C语言功底: 指针、内存管理、系统调用
  - 系统级编程思维: 并发、同步、错误处理
  - 性能优化意识: 缓存、批量操作、零拷贝
  - 架构理解能力: 分层设计、接口抽象、模块化

  这些纯C语言项目将为你转型驱动开发提供最直接和坚实的技术基础！

  ---
  ## zed
  
下面是我为你筛选并整理的 GitHub 项目（均满足 star > 1k），这些项目对有 Linux 应用开发背景、想转为 Linux 驱动工程师的人特别有帮助。我按“学习价值 / 实战价值 / 难度 / 适用方向”给出短评和上手建议，便于你快速选取和安排学习路线。

说明/筛选条件
- 只列出 GitHub stars 大于 1k 的仓库（我在整理时以 GitHub 页面/搜索结果显示的 star 数为准；实际 star 会随时间变化，仓库链接里可以看到最新数值）。  
- 项目类型覆盖：内核源码、模块教程/LDD 示例、eBPF/XDP（当代与驱动紧密相关的内核扩展）、内核/性能调试工具、以及优秀的资源集合。

精华清单（按优先级与典型学习路线）

1) Linux 内核源码 — torvalds/linux (Star ≈ 200k+)
- 链接：https://github.com/torvalds/linux  
- 为什么值得读：这是驱动开发的“母本”。所有真实驱动都在这里（`drivers/` 下按子系统组织），学会在内核树中定位并阅读驱动代码是必须技能。  
- 上手建议：先在 `drivers/char/`、`drivers/net/`、`drivers/block/` 找小型驱动阅读实现；看 `Documentation/` 下的子系统文档（device model、driver model 等）。实践：把某个较小驱动读懂并在本地编译内核或模块。  
- 适用方向：所有驱动方向（字符/网络/块/PCI/USB/等等）。

2) linux-insides — 0xAX/linux-insides (Star ≈ 30k)
- 链接：https://github.com/0xAX/linux-insides  
- 为什么值得读：系统化、逐章解释内核启动、调度、内存、系统调用、异常/中断等内核内部机制，适合把用户态经验补齐到内核层面的知识。  
- 上手建议：按章节读：Booting、Interrupts、Memory、Scheduler、System Calls。读完一个概念后回到内核源码对照查看实现。  
- 适用方向：理论与内核机制理解（对写可靠驱动必备）。

3) Linux Kernel Module Programming Guide — sysprog21/lkmpg (Star ≈ 7k–8k)
- 链接：https://github.com/sysprog21/lkmpg （并有 `examples/`）  
- 为什么值得读：非常实用的 LKM（内核模块）教程和范例，适合从“应用开发”快速上手模块开发。例子会从简单 Hello 到字符设备、IOCTL、设备树等。  
- 上手建议：先 clone，然后在 `examples/` 中逐步编译/运行 Hello、字符设备示例。常用编译命令（在内核外构建模块）如 `make -C /lib/modules/$(uname -r)/build M=$(pwd) modules`，加载用 `insmod`，查看 `dmesg` 输出。  
- 适用方向：初学者实践（模块构建、file_operations、内核同步、IOCTL、内存拷贝等）。

4) LDD3 例子（更新版）— martinezjavier/ldd3 等（Star ≈ 2k）
- 链接：https://github.com/martinezjavier/ldd3  
- 为什么值得读：这是 O’Reilly 的经典书《Linux Device Drivers (LDD3)》的示例代码的现代内核移植版本（包含 `scull` 等传统练习），适合动手练习驱动典型模式（字符设备，阻塞/非阻塞 I/O、内核同步等）。  
- 上手建议：以 `scull/` 和 `shortprint/` 为入门练习：编写用户态测试程序调用驱动、练习 `ioctl`、并发访问场景的同步处理。  
- 适用方向：字符驱动、学习驱动的基本范式与习惯做法。

5) BPF 工具与示例：iovisor/bcc (Star ≈ 20k+)
- 链接：https://github.com/iovisor/bcc  
- 为什么值得读：BCC 提供大量 eBPF 示例/工具（`tools/` 目录里有 `opensnoop`、`execsnoop` 等），是了解内核观测、调试驱动问题、抓取运行态行为的实战工具。很多现代驱动开发/调试都用到 BPF 工具链。  
- 上手建议：安装 bcc（或用容器），运行现成工具观察系统行为，然后读 `examples`、`tools` 学习如何从内核抓取事件、栈信息。  
- 适用方向：驱动调试、性能分析、Tracing。

6) bpftrace — iovisor/bpftrace (Star ≈ 9k+)
- 链接：https://github.com/iovisor/bpftrace  
- 为什么值得读：高层 tracing 语言（类似 awk 风格），快速验证内核/驱动的运行时行为，入门门槛低，能帮助你在没改驱动源代码的前提下洞察问题。  
- 上手建议：用 `opensnoop.bt`、`runqlat.bt` 等脚本观察内核行为，逐步改写并实验。  
- 适用方向：调试与性能分析（短期高产出）。

7) libbpf — libbpf/libbpf (Star ≈ 2k+)
- 链接：https://github.com/libbpf/libbpf  
- 为什么值得读：写现代 eBPF 程序、使用 CO-RE（compile once — run everywhere）方式，以及 libbpf 的进阶 API。对网络驱动/内核扩展、零拷贝方案（AF_XDP）非常有帮助。  
- 上手建议：看 `examples/`（加载器、skeleton 用法），结合下列 XDP 教程练手。  
- 适用方向：现代内核扩展、网络数据面、高性能驱动辅助工具。

8) XDP 教程 — xdp-project/xdp-tutorial (Star ≈ 1.6k–1.7k)
- 链接：https://github.com/xdp-project/xdp-tutorial  
- 为什么值得读：XDP 是网络驱动/协议前置处理的重要技术，可以在 NIC 层做高速包处理。对想做网络驱动 / 网卡加速方向的人非常关键。  
- 上手建议：按课程逐步完成 `basicXX`、`packet01-parsing` 等 lesson。需要配置 `clang`、`libbpf`、`xdp-tools` 等依赖。  
- 适用方向：网络驱动、网卡编程、AF_XDP。

9) Cilium — cilium/cilium (Star ≈ 10k–20k)
- 链接：https://github.com/cilium/cilium  
- 为什么值得读：大型生产级 eBPF 项目，展示了 kernel-level datapath（bpf 程序）与 user-space agent 的工程化集成。看它可以理解如何在复杂系统中把内核扩展、性能、可观测性和安全结合起来。  
- 上手建议：阅读 `bpf/`、`pkg/datapath/`、以及 agent 与内核交互的代码路径。适合进阶工程实践学习。  
- 适用方向：生产化 eBPF/网络驱动系统设计。

10) FlameGraph — brendangregg/FlameGraph (Star ≈ 18k+)
- 链接：https://github.com/brendangregg/FlameGraph  
- 为什么值得读：对驱动性能优化、CPU 热点查找、分析上下文切换和内核栈非常有用。驱动性能调优必备工具之一。  
- 上手建议：通过 `perf` + `flamegraph.pl` 生成火焰图来定位内核函数/驱动函数的热点；熟悉 `stackcollapse-*` 工具链。  
- 适用方向：性能分析、调优、回归验证。

11) 资源索引/集合 — awesome-ebpf / 类似合集（Star ≈ 4k+）
- 链接（示例）：https://github.com/zoidyzoidzoid/awesome-ebpf  
- 为什么值得读：汇总了大量 eBPF/XDP/Tracing 的高质量资料、库、教程，方便你按主题深挖。  
- 上手建议：按你关注的方向（network/observability/security）查看相关子项目与示例。

—— 我还排除了 star < 1k 的一些有用小仓库（例如部分 LDD 练习仓库、特定硬件驱动的教学仓等），可以按你关注的具体方向再拉进来。

建议的阶段性学习路线（面向有应用经验、目标转驱动工程师）

- 环境准备（1–3 天）
  - 在隔离环境（VM / QEMU / 容器）准备内核 headers、clang、libbpf、bpftrace、bcc 等。  
  - 学会安全地插卸模块（`insmod`/`rmmod`）、读日志（`dmesg`）、读符号（`modinfo`）。

- 基础入门（1–2 周）
  - 跟着 `sysprog21/lkmpg` 的 `examples`：实现并理解 Hello 模块、字符设备、简单 `ioctl`、module param。  
  - 完成 `martinezjavier/ldd3` 中 `scull` 示例，写用户端测试程序。  

- 内核机制补强（2–4 周）
  - 精读 `linux-insides` 的 Boot、Memory、Interrupts、Scheduler；并在 `torvalds/linux` 中对照实现。  
  - 学习内核同步（spinlock、mutex、rcu）、内存分配（kmalloc/kfree/slab）、睡眠/阻塞模型。

- 调试与观测（1–2 周）
  - 学会 `perf`、`FlameGraph`、`bpftrace`、`bcc` 工具，定位驱动问题与性能瓶颈。  
  - 用 bcc/bpftrace 写几条 trace 脚本来观察自己写的驱动行为。

- 进阶方向（1–2 个月）
  - 网络驱动方向：做 XDP 实验（`xdp-project/xdp-tutorial`）、学 `libbpf`、尝试 AF_XDP 示例。  
  - 存储/块驱动方向：研究 kernel 的 block 层和 `drivers/block`，尝试简单 ramdisk/虚拟块设备实现。  
  - 实战与贡献：尝试给 `lkmpg`、`ldd3` 示例或 `xdp-project` 提交小修复/文档改进，再逐步尝试修复 kernel 中的小 bug（先找 `good first issue`、`help wanted`）。

具体的 3 个入门练习（可以马上开始）
1. 用 `sysprog21/lkmpg` 的 Hello 模块：编译、加载、卸载，观察 `dmesg`；修改模块添加 module 参数并通过 sysfs/`module_param` 传值。  
2. 复现并扩展 `scull`：实现 `write` 的阻塞/非阻塞两种行为，写一个并发测试程序，观察 race 与加锁效果。  
3. 用 `bpftrace` 写一个脚本统计 `open()` 调用分布（使用 bpftrace 的 `tracepoint:syscalls:sys_enter_openat`），理解用户态->内核态的调用链并用 FlameGraph 做热点分析。

下一步我可以为你做的事（你选其一或多个）：
- 把上面列表按“驱动类型（字符/网络/块/USB）”细分并给出每类 5 个高价值仓库；  
- 根据你可投入的周时长（比如每天 1 小时 / 每天 3 小时）制定 8–12 周的详细学习计划（含练手任务、检查点、提交 PR 建议）；  
- 为某个仓库（例如 `sysprog21/lkmpg` 或 `xdp-project/xdp-tutorial`）给出“新手上手手册”，包含具体命令、常见错误与调试步骤（我会给出可复制的命令和测试程序）。  

需要你回复的两件事（用于我做更精确的后续整理）
1. 你希望专注哪类驱动？（字符 / 网络 / 块 / PCI / USB / 通用内核/可观测性等）  
2. 想要的产出（只要“候选仓库清单”就够？还是要“详细学习计划/按天任务/PR 指南”？）

你先告诉我你的偏好，我就按你需要做下一步更细的整理（比如把仓库按“网络驱动优先”或“硬件驱动（PCI/USB）优先”重新排序并扩展每个仓库的初学任务）。

## User

1. 我想专注基础到复杂的驱动
2. 按天的详细学习计划

## Assistant

下面给出一份“从基础到复杂驱动”的 12 周（5 天/周、共 60 个学习日）的逐日学习计划。每个学习日都包含：目标、推荐阅读/参考仓库、实操任务、交付/检查点。建议每日投入 2–4 小时（可按你实际时间调整）。周末作为复盘 / 弥补 / 深入阅读时间。

如果你想压缩成 8 周或拉长到 16 周，我可以按你时间再改。先假定“平衡节奏”：12 周完成基础到复杂的全栈驱动能力（含内核构建、QEMU 验证、调试、性能、KUnit 与上游提交流程）。

先给出必要的准备与关键命令（只列出关键的 shell 命令示例，复制到你的环境里执行；代码/命令块采用示例路径格式以便阅读）：

- 环境安装（Ubuntu / Debian 风格示例）
```/dev/null/setup-env.sh#L1-12
sudo apt update
sudo apt install -y build-essential git bc bison flex libelf-dev libssl-dev libncurses-dev \
    dwarves qemu-system-x86 qemu-kvm docker.io clang llvm pkg-config libclang-dev \
    linux-headers-$(uname -r) perf bpfcc-tools bpftrace
```

- 常用仓库 clone（作为练习材料）
```/dev/null/clone-repos.sh#L1-8
git clone https://github.com/sysprog21/lkmpg.git
git clone https://github.com/martinezjavier/ldd3.git
git clone https://github.com/torvalds/linux.git         # 内核源码（可视需要 clone 特定分支）
git clone https://github.com/xdp-project/xdp-tutorial.git
git clone https://github.com/libbpf/libbpf.git
git clone https://github.com/iovisor/bcc.git
git clone https://github.com/brendangregg/FlameGraph.git
```

- 基本模块编译 / 加载 / 卸载（示例）
```/dev/null/build-module.sh#L1-6
# 假设当前目录包含模块源码和 Makefile
make -C /lib/modules/$(uname -r)/build M=$(pwd) modules
sudo insmod hello.ko
dmesg | tail -n 20
sudo rmmod hello
```

- 简单编译内核（用于 QEMU 测试；注意：耗时较久）
```/dev/null/build-kernel-qemu.sh#L1-6
cd ~/linux
make defconfig
make -j$(nproc)
# 启动 QEMU 内核（示例，需准备 rootfs）
qemu-system-x86_64 -enable-kvm -m 2G -kernel arch/x86/boot/bzImage -append "root=/dev/sda rw console=ttyS0" \
    -drive file=rootfs.img,format=raw -nographic
```

- 性能采样 + 火焰图（示例）
```/dev/null/perf-flamegraph.sh#L1-6
# 采样 30s
sudo perf record -F 99 -a -g -- sleep 30
sudo perf script > out.perf
./stackcollapse-perf.pl out.perf > out.folded
./flamegraph.pl out.folded > perf.svg
# 打开 perf.svg 查看火焰图
```

高阶目标与里程碑（供参考）
- Week 1–2：模块/字符设备上手（能写、编译、加载、测试字符设备驱动）
- Week 3–4：同步/中断/底半部、内核构建与 QEMU 调试（能在 VM/QEMU 上加载模块并调试）
- Week 5：块设备（实现一个简单的 ramdisk / block driver，并用 fio 测试）
- Week 6：PCI/USB/平台驱动入门（在 QEMU 上做虚拟设备或用现成虚拟设备）
- Week 7：设备树 / 片上系统（Platform driver + DT 绑定）
- Week 8：电源管理、时钟/调压器、PM 支持
- Week 9：KUnit、Kselftest、KASAN / lockdep / checkpatch
- Week 10：网络驱动与 XDP/eBPF（netdev、XDP、AF_XDP 零拷贝）
- Week 11：用户态驱动（UIO / VFIO）、SR-IOV、性能调优、免阻塞设计
- Week 12：上游贡献流程、最终集成项目、面试题与代码审查

下面进入逐日计划（按周分组，每天给出 1–3 项核心任务与交付物）。为便于阅读，我将每周的 5 天按 Day 1..Day 5 列出。你可以把每天的任务放进待办工具（GitHub Issue / Todoist / Notion）并把实现作为 PR 或 Gist 保存。

第 1 周 — 环境与第一个模块（基础）
- Day 1 — 环境搭建与仓库准备
  - 目标：完成开发环境（编译器、kernel headers、QEMU、bpf 工具）与示例仓库 clone。
  - 阅读：`sysprog21/lkmpg` README，`ldd3` 简介。
  - 实操：按上面的安装与 clone 命令执行，确认 `gcc`、`make`、`qemu`、`clang` 可用。
  - 交付：截图或记录安装输出与 `git clone` 的仓库位置。

- Day 2 — Hello kernel module（第一份模块）
  - 目标：理解最小模块生命周期（init/exit）、`printk` 级别。
  - 阅读：`lkmpg` 的 hello 示例（examples/hello*）。
  - 实操：编译并加载 `hello` 模块，查看 `dmesg` 输出，卸载模块。
  - 交付：`dmesg` 输出文本，确保模块可多次加载卸载。

- Day 3 — 模块参数 + `sysfs` + `module_param`
  - 目标：学会如何把配置传给模块并且通过 sysfs 暴露状态。
  - 阅读：`lkmpg` 的 module-parameter 示例。
  - 实操：扩展 hello 模块，增加一个 `module_param` 整数和 `sysfs` attribute；读写该属性。
  - 交付：用户级脚本读写该 sysfs 属性并记录输出。

- Day 4 — 字符设备概念（`cdev`/`file_operations`）
  - 目标：理解 `file_operations`、注册字符设备、`mknod` 创建设备节点。
  - 阅读：`ldd3` 的 `scull` 简介（或 `lkmpg` 对应章节）。
  - 实操：实现最小的字符设备：实现 `open`, `read`, `write`，并用用户态测试程序 `open/read/write`。
  - 交付：用户态测试程序打印读到的数据、设备号信息。

- Day 5 — `copy_to_user` / `copy_from_user` 与简单同步
  - 目标：掌握用户态与内核态内存拷贝接口及错误处理。
  - 阅读：`lkmpg` & `ldd3` 中关于 `copy_*_user` 的章节。
  - 实操：在字符设备中实现从用户写入一个 struct，然后内核验证并返回结果。
  - 交付：用户态测试程序、模块代码片段、`dmesg` 验证运行正确。

第 2 周 — 并发、IOCTL、阻塞/非阻塞与测试
- Day 6 — 并发基础：spinlock / mutex / semaphore / atomic
  - 目标：理解并发控制原语的适用场景与 API。
  - 阅读：内核并发章节（`lkmpg`/`linux-insides` 对应章节）。
  - 实操：在字符设备中加入 `mutex` 或 `spinlock`，模拟并发访问（多个线程写）。
  - 交付：演示 race 条件与加锁后的输出对比。

- Day 7 — 阻塞 IO / wait queues / poll
  - 目标：实现阻塞读写，学会 `wait_event` / `wake_up` 与 `poll`。
  - 实操：把字符设备变成一个阻塞队列，用户线程 `read` 将在无数据时阻塞。
  - 交付：并发测试脚本展示阻塞与唤醒流程。

- Day 8 — `ioctl` / `unlocked_ioctl` / `compat_ioctl`
  - 目标：掌握驱动与用户态复杂控制交互。
  - 实操：在驱动中实现数个 `ioctl` 命令，写用户态工具调用。
  - 交付：完整 `ioctl` 调用示例与注释。

- Day 9 — 单元测试与自动化（最小化）
  - 目标：用 shell / python 脚本自动运行你的测试用例。
  - 实操：写脚本自动化加载模块、运行测试、检查 `dmesg`／设备输出、卸载模块。
  - 交付：CI-style 测试脚本（可在本地运行）。

- Day 10 — 回顾与小 milestone（交付）
  - 目标：把前两周的练习整理成 README：如何构建、运行、测试。
  - 实操：把代码 push 到个人仓库并写 README / 演示命令。
  - 交付：Git 仓库链接 + README。

第 3 周 — 内核构建、QEMU 与调试
- Day 11 — 下载内核源码、配置基础知识
  - 目标：可以配置并局部编译内核或模块、理解 `Kbuild`。
  - 阅读：`linux/` 顶层 `Documentation/` 基本指南。
  - 实操：`make menuconfig` / `make` （或 `make bzImage`）并理解输出。
  - 交付：一份 kernel config 的摘要（记录更改点）。

- Day 12 — 使用 QEMU 引导 kernel、准备 rootfs
  - 目标：搭建 QEMU 测试环境（不影响本机系统）。
  - 实操：制作最小 rootfs，使用 `qemu-system-x86_64 -kernel` 启动并获得 console。
  - 交付：QEMU 启动日志、能登录的 shell。

- Day 13 — 在 QEMU 中加载模块并调试
  - 目标：在 guest 中加载你的模块并复现测试用例。
  - 实操：把模块拷贝到 guest（`scp` 或 qemu 共享），`insmod`，观察 dmesg。
  - 交付：guest 中模块运行截图 / 日志。

- Day 14 — 内核打印与动态调试（`printk`、`dynamic_debug`）
  - 目标：掌握内核日志等级、如何减少 log flooding、如何临时打开内核 debug。
  - 实操：用 `dynamic_debug` 打开模块特定调试点，测量输出。
  - 交付：日志示例与 `dynamic_debug` 用法说明。

- Day 15 — KGDB / KDB 概览（理论 + 小实验）
  - 目标：知道如何用 `kgdb` 在内核中断点调试（注意：需要特别配置）。
  - 阅读：`linux` 文档中的 KGDB 指南。
  - 实操（可选）：在虚拟机中尝试最小的 kgdb 测试（若环境复杂可先阅读并记录步骤）。
  - 交付：KGDB 流程步骤文档。

第 4 周 — 中断、bottom-half、延迟工作与 DMA 基础
- Day 16 — 中断处理：`request_irq` / `free_irq` / IRQ flags
  - 目标：实现中断处理函数并理解 top-half/bottom-half 的限制。
  - 实操：写一个假定 IRQ 的驱动（可用 gpio 中断或虚拟中断）。
  - 交付：中断触发/处理日志与代码段。

- Day 17 — bottom-half：tasklets / workqueue / threaded IRQ
  - 目标：掌握延迟处理机制与使用场景。
  - 实操：把工作从 IRQ top-half 推到 workqueue / tasklet，并比较差异。
  - 交付：延迟处理的性能/正确性对比说明。

- Day 18 — 定时器：`hrtimer` 与 `timer_list`
  - 目标：用内核定时器做周期任务或超时处理。
  - 实操：实现一个驱动周期复习任务（例如每秒统计一次）。
  - 交付：定时器可靠性说明与代码。

- Day 19 — DMA（概念、API、`dma_map_single`、`dma_alloc_coherent`）
  - 目标：理解内核 DMA API、缓存问题与 coherent vs streaming。
  - 阅读：`linux` 文档关于 DMA mapping 的章节；`lkmpg` 的相关章节。
  - 实操：模拟 DMA buffer 分配并记录映射/同步步骤（如果无真实设备，先做 API 层实验）。
  - 交付：DMA 分配/映射代码样例与注释。

- Day 20 — 使用 UIO 模拟设备/用户态驱动（实验）
  - 目标：使用 `uio` 驱动把设备寄存器映射给用户空间，理解用户态驱动模式。
  - 实操：在 guest 中加载 `uio_pci_generic` 或类似并写用户态程序访问 `mmap`。
  - 交付：用户态访问示例 + 性能初探。

第 5 周 — 块设备简介与实现（ramdisk / virtual block）
- Day 21 — block device 架构（`gendisk`、`request_queue`、`bio`）
  - 目标：理解块设备注册、请求处理流程。
  - 阅读：`linux` block subsystem 文档与 `lkmpg` block 章节。
  - 交付：架构图/流程图。

- Day 22 — 简单 ramdisk（基于 LDD3 示例）
  - 目标：实现或移植一个内存后端的块设备（ramdisk）。
  - 实操：编译并注册 block device，能被 `mkfs`、`mount` 使用。
  - 交付：成功 `mkfs.ext4` 并 mount 到 guest 的截图/日志。

- Day 23 — request handling 与并发
  - 目标：处理并行 IO 请求，理解 BIO lifecycle。
  - 实操：在你的 ramdisk 中实现并发请求处理，并用 `fio` 做压力测试。
  - 交付：fio 性能数据与分析（latency/throughput）。

- Day 24 — block 层调度与优化
  - 目标：了解 I/O scheduler 的影响（noop、deadline、cfq 等）。
  - 实操：切换调度器并对比性能数据。
  - 交付：对比报告与结论。

- Day 25 — 复盘：整理块设备实现过程与关键代码
  - 目标：把实现写成 README，包含构建/测试/性能测试脚本。
  - 交付：完整的 demo 仓库（或 fork），便于他人复现。

第 6 周 — PCI / USB 驱动基础（平台/总线驱动）
- Day 26 — Linux 设备模型 & platform driver（`platform_driver`）
  - 目标：理解 `struct device` / `driver` / `bus` / `device tree` 如何关联。
  - 实操：实现一个简单 `platform_driver`，在 probe 中注册 `cdev` 或 `netdev`。
  - 交付：probe / remove 日志与代码。

- Day 27 — PCI 驱动基础：`pci_register_driver` / BAR 映射
  - 目标：掌握 PCI 设备的 probe 流程与 BAR（Memory / IO）映射。
  - 实操：在 QEMU 中使用 `-device` 加载一个虚拟 PCI 设备（如 virtio 或 e1000），写驱动读取 BAR。
  - 交付：驱动能在 probe 中读取 BAR 并输出资源信息。

- Day 28 — PCI 中断、MSI 与 DMA
  - 目标：处理 PCI 中断并配置 DMA（如果设备支持）。
  - 实操：启用 MSI（若虚拟设备支持）并处理 IRQ；使用 `pci_enable_msi`/`pci_disable_msi`。
  - 交付：中断处理日志与说明。

- Day 29 — USB 驱动基础：`usb_register` / urb
  - 目标：理解 USB 驱动的 probe/disconnect、提交 URB。
  - 实操：用一个简单的 USB 设备（或 QEMU 的虚拟 USB）写 probe/disconnect skeleton。
  - 交付：能识别设备并提交/完成 URB 的 demo。

- Day 30 — USB 数据流与同步模式
  - 目标：掌握同步/异步 URB、isochronous 传输（概念性）。
  - 交付：USB 驱动的测试脚本与流程说明。

第 7 周 — 设备树、I2C/SPI、GPIO / pinctrl
- Day 31 — 设备树（DT）基础：节点 / compatible / bindings
  - 目标：学会写一个简单的 DT 节点并在驱动中用 `of_match_table` 绑定。
  - 实操：在 QEMU 或 ARM 模拟环境中加载 DT 并验证绑定。
  - 交付：DT 片段与驱动 probe 的配对说明。

- Day 32 — GPIO / pinctrl 概念
  - 目标：使用 `gpiod_*` API 控制 GPIO，理解 pinctrl 的职责。
  - 实操：使用 `gpiolib` 模拟或真实硬件完成 GPIO toggling。
  - 交付：GPIO 控制的 demo 程序。

- Day 33 — I2C 驱动（client/adapter）与 SPI 简介
  - 目标：学会实现一个 I2C client 驱动（probe / read / write）。
  - 实操：用 `i2c-stub` 或 `i2c-tools` 在 guest 中模拟硬件并测试。
  - 交付：I2C 驱动示例和测试脚本。

- Day 34 — 平台驱动结合 DT：GPIO + I2C + clock
  - 目标：把前几天学到的技术在一个 platform driver 里集成。
  - 实操：实现一个平台驱动，probe 时获取 `gpio`, `i2c` 和 `clk` 资源并初始化。
  - 交付：probe 运行日志与资源获取代码。

- Day 35 — 复盘：硬件抽象层与子系统（总结文档）
  - 目标：把 platform + DT + 子系统的常见模式写成笔记，便于后续快速上手具体硬件。
  - 交付：一页总结（指南）。

第 8 周 — 电源管理（PM）、时钟与调压器
- Day 36 — PM 基础：`suspend` / `resume` hooks
  - 目标：理解系统 suspend/resume 与设备 PM 的关系。
  - 实操：在 driver 中实现 `pm_ops` 的 `suspend` / `resume` 并在 guest 中触发 suspend。
  - 交付：系统 suspend/resume 流程日志。

- Day 37 — runtime PM（`pm_runtime_*`）与自动化
  - 目标：实现 runtime PM，学会 `pm_runtime_get_sync`/`put`.
  - 实操：把驱动的 probe/init 操作合入 runtime PM lifecycle，并验证。
  - 交付：runtime PM 行为示例与测量。

- Day 38 — clocks 与 regulators (`clk_get`, `regulator_get`)
  - 目标：在驱动中正确获取并使用时钟与调压器资源。
  - 实操：在 platform driver 中调用 `clk_enable` 等接口并测量功耗/功能变化（理论或模拟）。
  - 交付：资源获取代码与错误处理策略。

- Day 39 — 深入 PM：resume 延迟/条件处理、suspend race
  - 目标：分析常见 PM race 情况并学习解决策略。
  - 实操：人为触发 race 情景并写修复（锁/ordering）。
  - 交付：race 场景复现脚本与修复补丁草案。

- Day 40 — 集成练习：给你的 platform 驱动加 PM 支持并测试
  - 交付：完整的驱动分支（含 PM）与运行日志。

第 9 周 — 测试、Sanitizers、静态检查
- Day 41 — KUnit 基础：内核单元测试框架
  - 目标：了解如何写 KUnit 测试并在内核构建中执行。
  - 实操：为你的字符设备/核心逻辑写 1-2 个 KUnit 测试用例。
  - 交付：KUnit 测试结果输出。

- Day 42 — kselftest 与自测套件
  - 目标：运行并编写内核自测脚本（`tools/testing/selftests`）。
  - 实操：在 guest 中运行若干 selftests 并记录结果。
  - 交付：自测运行日志 + 改进建议。

- Day 43 — KASAN / KCSAN / lockdep（动态检测）
  - 目标：学会在内核下启用 KASAN 或 lockdep 以发现内存/并发 bug。
  - 实操：在测试内核配置中启用 KASAN 并复现（或故意触发）一个 memory bug，观察输出。
  - 交付：KASAN 输出与错误定位说明。

- Day 44 — 静态检查工具：`sparse`、`checkpatch.pl`、`clang` 静态分析
  - 目标：把代码风格与静态检查纳入开发流程。
  - 实操：运行 `checkpatch.pl`、`sparse`，并修正若干警告。
  - 交付：静态检查报告与已修复的 PR/commit。

- Day 45 — 总结：把你的驱动补上测试、sanitizer 支持，并写一页“如何运行测试”说明
  - 交付：测试运行说明 + 测试脚本（放在 repo 中）。

第 10 周 — 网络驱动、XDP 与现代 datapath
- Day 46 — `net_device` API 基础（`alloc_netdev` / `register_netdev`）
  - 目标：理解 netdev 的生命周期与 ndo ops（`ndo_start_xmit`、`ndo_open` 等）。
  - 实操：实现一个最小 netdev skeleton（不是真正发送到线卡，只用于 flow）。
  - 交付：netdev skeleton 运行日志。

- Day 47 — TX/RX 路径、NAPI 简介
  - 目标：理解 NAPI 收包模型与中断/轮询切换。
  - 实操：在 skeleton 中模拟 NAPI 收包并记录数据路径延迟。
  - 交付：NAPI 的模拟 demo。

- Day 48 — XDP 基础（`xdp-project/xdp-tutorial`）
  - 目标：了解 XDP 程序如何在网络入口层处理包，能编译一个简单的 XDP pass/drop 程序。
  - 实操：按 tutorial 编译并加载一个 XDP 程序，观察处理效果（`ip`/`ping`）。
  - 交付：XDP 程序运行日志。

- Day 49 — libbpf / AF_XDP / 零拷贝基础
  - 目标：掌握 AF_XDP 的零拷贝思路与 libbpf skeleton 使用。
  - 实操：运行 `xdp-project/bpf-examples` 中的 AF_XDP 示例并验证通过。
  - 交付：AF_XDP 示例运行脚本与性能初测。

- Day 50 — 用 bpftrace / bcc 观察网络路径（Tracing）
  - 目标：用 bpftrace 或 bcc 收集内核中 netdev 的路径信息与延迟。
  - 实操：运行 `opensnoop`、`runqlat` 等工具观察内核行为，结合 `perf` 做火焰图。
  - 交付：一个小报告：XDP/AF_XDP 对比传统 netdev 的性能测量（示例）。

第 11 周 — 用户态驱动、VFIO、SR-IOV 与高阶性能优化
- Day 51 — UIO（用户空间驱动）原理与示例
  - 目标：掌握让用户空间直接访问设备寄存器的基本模式。
  - 实操：实现一个 UIO 驱动在内核注册并在用户态 mmap 访问。
  - 交付：用户态驱动 demo。

- Day 52 — VFIO 与用户态 PCI 驱动
  - 目标：理解 vfio 的 IOMMU 与安全模型，以及如何把设备直通给用户空间。
  - 阅读：VFIO 文档与示例（如 intel vfio docs）。
  - 交付：vfio 概念笔记与可能的测试计划（若硬件不可用可拟稿）。

- Day 53 — SR-IOV 概念与实现要点
  - 目标：了解虚拟功能（VF）/物理功能（PF）在驱动中的处理差异。
  - 交付：SR-IOV 学习笔记与在虚拟化场景下的测试计划。

- Day 54 — 无锁数据结构、RCU、refcount_t
  - 目标：学习 lockless 设计的基本要点与 RCU 的正确使用场景。
  - 实操：把驱动中读多写少的场景用 RCU 改写并用压力测试验证。
  - 交付：性能对比报告。

- Day 55 — 性能优化循环（测量→定位→优化→回归）
  - 目标：完整性能优化流程（`perf`、火焰图、内核统计）。
  - 实操：用 `perf` + `flamegraph` 定位驱动热点并优化。
  - 交付：优化前后对比数据与 patch。

第 12 周 — 上游提交流程、最终工程化项目、面试准备
- Day 56 — kernel git / 上游流程：`format-patch` / `get_maintainer.pl`
  - 目标：掌握生成 patch、`Signed-off-by`、`checkpatch.pl`、发送邮件给 LKML 的基本流程。
  - 实操：把一个小修复做成 patch，并运行 `checkpatch.pl`。
  - 交付：合规的 patch 文件与 `git format-patch` output。

- Day 57 — 选择最终项目：定义 scope（示例：虚拟块驱动 + PM + KUnit）
  - 目标：写出最终项目的目标、接口、测试矩阵与时间表。
  - 交付：项目计划文档（包含验收条件）。

- Day 58 — 实现最终项目（Day1）：骨架与基本功能
  - 目标：实现基础功能并通过基本测试。
  - 交付：第一个可运行提交（PR/patch）。

- Day 59 — 实现最终项目（Day2）：测试、PM、性能
  - 目标：补齐测试（KUnit / user tests），保证 PM 正确，进行一次性能测试并记录结果。
  - 交付：测试结果、性能数据、修复日志。

- Day 60 — 准备上游 PR / 代码审查与演示
  - 目标：准备 patch/PR，写好描述、测试步骤、`Signed-off-by`，进行模拟代码审查（自己或同伴 review）。
  - 交付：最终 patch/PR 链接（或 patch 文件）、演示视频或运行脚本、项目总结（README + 使用说明）。

每周回顾与评估（每周第 6 日 / 周末）
- 每周末花 2 小时回顾该周笔记、补完没做完的练习、把关键学习点写入个人知识库（如 Notion、GitHub Wiki）。
- 记录 3 个你仍然不理解的问题并在下一周把它们解决（找文档 / 发 Issue / 在内核邮件列表寻求帮助）。

额外建议（工具、资源、面试准备）
- 必备资源（阅读/练习）：
  - `sysprog21/lkmpg`（内核模块教程与示例） — https://github.com/sysprog21/lkmpg  
  - `martinezjavier/ldd3` / LDD3 示例（经典案例） — https://github.com/martinezjavier/ldd3  
  - `0xAX/linux-insides`（内核机制） — https://github.com/0xAX/linux-insides  
  - `xdp-project` 与 `libbpf`（现代 BPF / XDP） — https://github.com/xdp-project/xdp-tutorial & https://github.com/libbpf/libbpf  
  - `iovisor/bcc` / `iovisor/bpftrace`（tracing 工具） — https://github.com/iovisor/bcc / https://github.com/iovisor/bpftrace  
  - `brendangregg/FlameGraph`（性能火焰图） — https://github.com/brendangregg/FlameGraph

- 面试/简历加分项：
  - 至少能讲清 3 个你写过驱动的设计决策（为什么用 mutex 而非 spinlock、为什么使用 workqueue、如何处理 PM）。
  - 有一个可复现的 demo 仓库（包含 README、测试脚本、KUnit 测试）。
  - 能解释你的驱动如何处理并发、如何做错误恢复、如何在没有硬件的情况下做 CI。

- 安全提示与实践
  - 永远在虚拟机或测试硬件上进行驱动实验，避免在生产机器上直接插卸模块。
  - 对长时间运行修改使用 KASAN/KCSAN 检查内存/数据竞争。
  - 写测试覆盖常见边界条件（error path）。

我可以为你继续做的事情（选一项或多项）
- 把上面的 60 天计划转成每一天的 GitHub Issue 模板或 checklist（方便日常打卡与进度追踪）。  
- 为你选定的第一个 2 个练手任务（例如 `scull` 改造 + 一个简单 block 驱动）生成 starter repo（含 Makefile、测试脚本）并给出逐行注释。  
- 把计划压缩到 8 周或扩展到 16 周，并按你每天可用小时重新调节每天任务量。  

现在请告诉我：
1) 你每天大约可投入多少小时？（1h / 2–3h / 4+ h）  
2) 你更倾向于“理论优先”还是“立即动手优先”？（我会据此调整每日任务的深度与练习量）

确认后我会根据你的时间偏好把计划微调并（如果你需要）把前 2 天的 Starter 代码/脚本直接生成给你。

## User

1. 每天1个小时
2. 立即动手有线

## Assistant

很好 — 我已把学习节奏按你“每天 1 小时、偏重立即动手”的偏好重做为一个可执行的 24 周计划（共 120 个工作日，5 天/周）。总耗时与之前的 60 天×2 小时 的学习量接近，但把每天任务压缩为 1 小时内可完成的小步快跑，优先实战练习与即时反馈。

先给出高层要点（很重要）：
- 每日时间分配（1 小时）：10–15 分钟快速阅读/定位；40–45 分钟动手编码或测试；5 分钟写下当日产出/问题（便于复盘）。  
- 工具/环境（建议）：Ubuntu/Debian 系列（或任意你习惯的发行版）、内核 headers、clang、perf、bpf 工具、QEMU（无硬件时用），以及一个用于放练习代码的 Git 仓库。  
- 交付方式：每天一个小产出（日志、测试脚本、代码片段或一段能重复运行的命令），每周一次周报（3–5 行），每阶段一个里程碑 demo（可放到 GitHub）。  
- 我已经把“第一周 / 前 10 天”做成可立即复制粘贴运行的 starter 示例（包含 kernel hello、Makefile、基本字符设备和用户态测试），在下方代码块中给出。你可以把这些文件拷贝到本地并在 1 小时内完成 Day1~Day3 的第一个小目标。

一：立即可跑的 Day-1~Day-3 starter（拷贝并运行）
- Day1：编译并加载最小 hello 模块（看内核日志）；
- Day2：把 hello 增加 module_param / sysfs（可从用户态传参）；
- Day3：编写一个最小字符设备驱动 + 用户态读写测试。

hello 模块（Day1）：
```/dev/null/hello.c#L1-60
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

static int __init hello_init(void)
{
    pr_info("hello: loaded\n");
    return 0;
}

static void __exit hello_exit(void)
{
    pr_info("hello: unloaded\n");
}

module_init(hello_init);
module_exit(hello_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Simple hello kernel module");
```

Makefile（适用于上面的模块）：
```/dev/null/Makefile#L1-40
obj-m += hello.o

KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
	$(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
	$(MAKE) -C $(KDIR) M=$(PWD) clean
```

快速 build & test 脚本（Day1）：  
```/dev/null/build_and_test.sh#L1-40
#!/bin/sh
set -e

# build
make

# insert module
sudo insmod hello.ko
sleep 1

# show kernel log
dmesg | tail -n 20

# remove module
sudo rmmod hello
sleep 1
dmesg | tail -n 20 || true

# clean
make clean
```

最小字符设备（Day3） — kernel 端（minichar）：
```/dev/null/minichar.c#L1-200
#include <linux/module.h>
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

#define DEV_NAME "minichar"
#define BUF_SIZE 512

static dev_t dev_number;
static struct cdev my_cdev;
static char device_buf[BUF_SIZE];
static size_t data_size;

static int minichar_open(struct inode *inode, struct file *file)
{
    pr_info("minichar: open\n");
    return 0;
}

static ssize_t minichar_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
{
    size_t to_copy = min(count, data_size - (size_t)(*ppos));
    if (to_copy == 0) return 0;
    if (copy_to_user(buf, device_buf + *ppos, to_copy))
        return -EFAULT;
    *ppos += to_copy;
    return to_copy;
}

static ssize_t minichar_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)
{
    size_t to_copy = min(count, (size_t)BUF_SIZE - (size_t)(*ppos));
    if (to_copy == 0) return -ENOSPC;
    if (copy_from_user(device_buf + *ppos, buf, to_copy))
        return -EFAULT;
    *ppos += to_copy;
    data_size = max(data_size, (size_t)(*ppos));
    return to_copy;
}

static const struct file_operations minichar_fops = {
    .owner = THIS_MODULE,
    .open = minichar_open,
    .read = minichar_read,
    .write = minichar_write,
};

static int __init minichar_init(void)
{
    int err;
    err = alloc_chrdev_region(&dev_number, 0, 1, DEV_NAME);
    if (err) return err;
    cdev_init(&my_cdev, &minichar_fops);
    my_cdev.owner = THIS_MODULE;
    err = cdev_add(&my_cdev, dev_number, 1);
    if (err) {
        unregister_chrdev_region(dev_number,1);
        return err;
    }
    pr_info("minichar: registered major=%d\n", MAJOR(dev_number));
    return 0;
}

static void __exit minichar_exit(void)
{
    cdev_del(&my_cdev);
    unregister_chrdev_region(dev_number, 1);
    pr_info("minichar: unregistered\n");
}

module_init(minichar_init);
module_exit(minichar_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Minimal character device");
```

用户态测试（Day3）：
```/dev/null/user_test.c#L1-200
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main(void) {
    int fd = open("/dev/minichar", O_RDWR);
    if (fd < 0) { perror("open"); return 1; }
    const char *msg = "hello kernel\n";
    if (write(fd, msg, strlen(msg)) < 0) { perror("write"); return 1; }
    lseek(fd, 0, SEEK_SET);
    char buf[128] = {0};
    int r = read(fd, buf, sizeof(buf)-1);
    if (r < 0) { perror("read"); return 1; }
    printf("read: %s", buf);
    close(fd);
    return 0;
}
```

二：为什么选 24 周（说明）
- 原 12 周计划假设每天 2–4 小时；把强度降到 1 小时/天后，为保证同样的覆盖面，把周期延长为约 24 周（120 个“1 小时”工作日）。  
- 你会以“每天完成一个小目标 + 每周整合一个里程碑 demo”的方法前进，既有即时成就感，又能逐步积累更复杂的能力。

三：按天（按周分块，便于每天 1 小时执行）  
下面是完整的 24 周按天清单（每周 5 天）。每个工作日写明：目标（10–15 分钟读）；实操（40–45 分钟）；交付（5 分钟）。（我把每项写得尽量精简，方便你每天 1 小时内完成）

Week 1 — 环境与第一个模块（入门）
- W1D1 — 目标：搭建开发环境（gcc、kernel-headers、make、qemu 可选）。任务：安装并 clone 上面提到的三个仓库。交付：列出安装结果（uname -r、gcc --version）。
- W1D2 — 目标：编译/加载 Hello 模块。任务：拷贝 hello.c + Makefile，运行 build_and_test.sh。交付：dmesg 输出截图/文本。
- W1D3 — 目标：理解 module_param 与 sysfs（传参）。任务：在 hello 模块添加一个 module_param（int）并在 init 时打印其值。交付：演示模块加载时传参（insmod hello.ko param=3）。
- W1D4 — 目标：字符设备基础概念。任务：阅读 file_operations，开始实现 minichar skeleton（拷贝上面的 minichar.c）。交付：模块可以注册并显示主设备号。
- W1D5 — 目标：完成用户态测试。任务：编译 user_test.c，mknod /dev/minichar（或使用 udev），运行测试。交付：测试输出文本。

Week 2 — 用户空间交互 + 并发基础
- W2D1 — 目标：copy_to_user / copy_from_user 的边界处理。任务：加入边界检查与错误返回路径测试。交付：异常路径测试日志。
- W2D2 — 目标：简单并发（mutex）。任务：在 write 中加入 mutex 保护，用两个并发用户线程做压力测试。交付：对比 race 前后日志或失败率。
- W2D3 — 目标：wait_queue（阻塞读）。任务：实现当无数据时 read 阻塞，写入时唤醒。交付：阻塞/唤醒 demo（脚本版）。
- W2D4 — 目标：实现 poll/select 支持。任务：在 fops 中实现 poll，以便 select 可被唤醒。交付：用户脚本演示 select 工作。
- W2D5 — 目标：简单 IOCTL。任务：添加 2 个 ioctl（例：GET_SIZE / CLEAR_BUF），写用户态调用。交付：ioctl 调用示例输出。

Week 3 — 自动化测试与模块健壮性
- W3D1 — 目标：自动化测试脚本。任务：写 shell 脚本自动 build/load/run tests/unload。交付：可重复运行的脚本。
- W3D2 — 目标：异常处理（卸载时资源回收）。任务：实现并验证在异常路径时释放资源（unregister、cdev_del）。交付：异常卸载日志。
- W3D3 — 目标：增加模块信息（proc/sys 或 debugfs）。任务：把一个计数器暴露到 debugfs。交付：读写 debugfs 的示例。
- W3D4 — 目标：增加日志等级与 dynamic_debug。任务：用 dynamic_debug 打开/关闭日志。交付：日志切换步骤与示例。
- W3D5 — 目标：小结 + 在仓库写 README（如何 build/test）。任务：整理本周产物并提交到你的 repo。交付：README 与简单 CI 说明（本地脚本）。

Week 4 — 内核构建、QEMU 基本使用
- W4D1 — 目标：下载内核源码并做简单配置（make defconfig / menuconfig）。任务：学习 KBuild 与 modules 编译流程。交付：记录你做的 config 更改点。
- W4D2 — 目标：在 QEMU 上引导内核（最小 rootfs）。任务：使用现成 rootfs 或 docker-export 制作镜像并启动 QEMU。交付：能登录的 QEMU 控制台截图。
- W4D3 — 目标：在 QEMU guest 上复现 Day1~Day3。任务：把模块编译或拷贝到 guest 并测试。交付：guest 测试日志。
- W4D4 — 目标：学习内核日志与 printk 等级。任务：把模块日志区分不同等级并观察（KERN_INFO/KERN_DEBUG）。交付：日志样例。
- W4D5 — 目标：KGDB/KDB 理论与准备。任务：阅读 KGDB 文档并记录启用步骤（如果不做实验则记录流程）。交付：KGDB 配置笔记。

Week 5 — 中断与延迟处理
- W5D1 — 目标：理解 request_irq/free_irq。任务：阅读中断 API，写一个模拟 IRQ 的驱动 skeleton（可用虚拟中断或 platform device）。交付：probe/irq 注册日志。
- W5D2 — 目标：实现 bottom-half（workqueue）。任务：把中断 top-half 简短处理，延迟工作交给 workqueue。交付：对比 top/bottom 处理的时序日志。
- W5D3 — 目标：使用 tasklet（学习差异）。任务：用 tasklet 实现同样的延迟处理，比较使用场景。交付：记录任务选择理由。
- W5D4 — 目标：实现 hrtimer 或 timer_list 的定期任务。任务：写定时器打印计数器示例。交付：定时器日志。
- W5D5 — 目标：总结中断处理常见陷阱（不可睡眠、长延迟）。任务：写一页小文档记录注意点。交付：文章 / README snippet。

Week 6 — DMA 概念与 UIO（用户态驱动）
- W6D1 — 目标：DMA 概念（coherent vs streaming）。任务：阅读 DMA mapping 文档并做笔记。交付：两种模式的对比表。
- W6D2 — 目标：模拟 DMA buffer 分配（API 层实验）。任务：在模块中调用 dma_alloc_coherent / dma_free_coherent 并打印地址。交付：示例代码与输出。
- W6D3 — 目标：了解 UIO 框架。任务：用 uio_pci_generic 或 uio_simple 启动一个用户态映射 demo。交付：用户态 mmap 读写示例。
- W6D4 — 目标：用户态驱动（基础）。任务：编写一个简单的用户态程序，直接 mmap 并写寄存器（模拟）。交付：程序输出。
- W6D5 — 目标：复盘 DMA/用户态驱动学习要点。任务：把常见错误（cache 与同步问题）写成 checklist。交付：checklist。

Week 7 — 块设备入门（范例：ramdisk）
- W7D1 — 目标：学习 block subsystem 基本概念（gendisk / request_queue / bio）。任务：阅读相关文档并画流程图。交付：流程图。
- W7D2 — 目标：ramdisk 概念实现。任务：查看 LDD3 的 ramdisk 示例并在内核中编译。交付：能被 mkfs/mount 的演示。
- W7D3 — 目标：实现最小请求处理（BIO）并读写数据。任务：在 ramdisk 中实现 submit_bio/complete_bio。交付：fio 基本测试结果。
- W7D4 — 目标：并发/性能测试。任务：用 fio 做并发测试并收集数据。交付：简单的性能表格。
- W7D5 — 目标：总结 block 驱动的关键点（队列、合并、错误处理）。任务：写总结笔记。交付：总结文档。

Week 8 — PCI 驱动基础与虚拟设备测试
- W8D1 — 目标：理解 PCI 资源、BAR、device/driver 匹配。任务：读 PCI 文档并在代码中打印 resources。交付：资源打印日志。
- W8D2 — 目标：用 QEMU 加载虚拟 PCI 设备（例如 virtio or e1000）。任务：在 guest 上识别设备并测试。交付：设备识别输出。
- W8D3 — 目标：实现 probe 中对 BAR 的 ioremap。任务：把 BAR 地址映射到内核并读写。交付：映射成功的输出/日志。
- W8D4 — 目标：学习 MSI 与中断处理在 PCI 中的应用。任务：在可用时启用 MSI 并响应中断。交付：中断处理日志。
- W8D5 — 目标：资源释放和错误 recovery。任务：在 driver 的 remove 中确保所有资源被释放。交付：remove 的日志和代码片段。

Week 9 — USB 驱动与更多平台设备
- W9D1 — 目标：USB 驱动的基本 probe/disconnect 模式。任务：读取 USB core 文档并写 skeleton。交付：skeleton 代码。
- W9D2 — 目标：提交 URB（bulk / interrupt）。任务：提交一个 URB 并在完成处理程序里打印数据。交付：URB 完成日志。
- W9D3 — 目标：USB 同步与错误处理。任务：模拟断开后清理 URB 的流程。交付：清理脚本或代码注释。
- W9D4 — 目标：Platform driver 与 DT 绑定基础。任务：用设备树的 compatible 字段把驱动匹配到设备并 probe。交付：device tree + probe 的日志。
- W9D5 — 目标：综合练习：把 platform + USB + IRQ 的知识做成一页带图示的笔记。交付：笔记。

Week 10 — 设备树（DT）、GPIO、I2C、SPI
- W10D1 — 目标：设备树语法与 binding 约定。任务：写一个小的 DT 节点并在内核中解析。交付：DT 节点与驱动配对示例。
- W10D2 — 目标：GPIO 控制（gpiod API）。任务：在驱动中获取 GPIO 并控制高低电平。交付：GPIO 操作日志。
- W10D3 — 目标：I2C client 驱动基础。任务：实现一个 i2c client 的 probe 与读写。交付：i2c 的读写示例。
- W10D4 — 目标：SPI 驱动入门（消息传输）。任务：实现 spi_sync 读写示例（如果没有硬件可模拟）。交付：示例代码。
- W10D5 — 目标：把 device-tree 与子系统资源整合到一个 platform 驱动 demo 中（小功能）。任务：实现 demo 并在 QEMU/guest 里验证。交付：demo 运行日志。

Week 11 — 电源管理（PM）、runtime PM
- W11D1 — 目标：系统 suspend/resume 基本流程。任务：实现 pm_ops 的 suspend/resume stub 并测试。交付：suspend/resume 日志。
- W11D2 — 目标：runtime PM 使用与策略。任务：在驱动中实现 pm_runtime_get/put 并测试。交付：runtime PM 的证明脚本。
- W11D3 — 目标：时钟（clk）与 regulator 使用。任务：在 platform 驱动里获取 clk/regulator 并启用。交付：资源获取日志。
- W11D4 — 目标：PM race 情况排查。任务：模拟 resume 过程中被用户态打断等 race 情形并修复（加锁/ordering）。交付：修复补丁/注释。
- W11D5 — 目标：PM 完整性测试。任务：多次 suspend/resume 并检查资源泄露。交付：测试日志。

Week 12 — 测试覆盖（KUnit / kselftest / KASAN）
- W12D1 — 目标：KUnit 基础。任务：为一个小函数写 KUnit 测试。交付：KUnit 通过输出。
- W12D2 — 目标：kselftest 简介并运行一套测试。任务：运行相关 selftests 并记录结果。交付：测试运行日志。
- W12D3 — 目标：启用 KASAN（测试内存错误）。任务：在测试内核中启用 KASAN 并运行有意的内存越界测试（小心）。交付：KASAN 报告（若触发）。
- W12D4 — 目标：静态检查（sparse、checkpatch）。任务：运行 checkpatch.pl 并修正若干警告。交付：修复的 commit。
- W12D5 — 目标：把测试集成到本地脚本。任务：编写一个脚本能在你的 dev 环境里自动跑 KUnit/kselftest。交付：脚本 + 运行说明。

Week 13 — 网络驱动（netdev / NAPI）入门
- W13D1 — 目标：net_device 的基本生命周期。任务：实现 netdev skeleton 并注册。交付：netdev 注册日志。
- W13D2 — 目标：TX path 的 ndo_start_xmit。任务：在 skeleton 中实现并记录函数调用顺序。交付：TX path 示意。
- W13D3 — 目标：RX path 与 NAPI 基本实现。任务：集成 napi_poll 并模拟收包。交付：napi poll 日志。
- W13D4 — 目标：netdev 调试（ethtool / netlink）。任务：实现一个 ethtool ops 示例并读取统计。交付：ethtool 输出。
- W13D5 — 目标：小结并用 perf 观察 netdev handler 时间。任务：运行 perf 并记录热点。交付：perf 输出摘要。

Week 14 — XDP / eBPF 基础
- W14D1 — 目标：eBPF/XDP 基本概念。任务：阅读 xdp-tutorial 的第一课并搭建依赖（libbpf、clang）。交付：环境验证（clang、bpftool、libbpf）。
- W14D2 — 目标：编写并加载一个最小 XDP pass/drop 程序。任务：按照 tutorial 编译并测试。交付：XDP 程序运行日志。
- W14D3 — 目标：使用 libbpf skeleton（CO-RE）加载 BPF 程序。任务：运行 bpf-examples 中的 sample。交付：skeleton 加载输出。
- W14D4 — 目标：AF_XDP 基础（零拷贝思路）。任务：阅读 AF_XDP 示例并运行。交付：AF_XDP 示例日志。
- W14D5 — 目标：用 bpftrace/bcc 做网络路径 tracing。任务：运行 opensnoop、runqlat 等并分析。交付：trace 输出与简短结论。

Week 15 — 高阶网络 / 性能优化
- W15D1 — 目标：测量 XDP 对流量处理的改善。任务：用 iperf(或自定义流量)对比普通 netdev 与 XDP drop。交付：对比数据。
- W15D2 — 目标：用 perf + flamegraph 定位 netdev 中的耗时热点。任务：生成火焰图并分析。交付：火焰图截图 + 1-2 点结论。
- W15D3 — 目标：TCP/UDP协议栈与驱动交互要点。任务：追踪 skb 流转路径。交付：简短路径笔记。
- W15D4 — 目标：多队列与 RSS（rx/tx queues）基础。任务：观察多队列在性能上的优势（模拟）。交付：测试结果。
- W15D5 — 目标：写一页“网络驱动性能优化清单”。任务：把常见优化写成 checklist。交付：checklist。

Week 16 — 用户态驱动（VFIO/用户态 PCI）
- W16D1 — 目标：VFIO 与 IOMMU 基础。任务：阅读 VFIO 文档并写简要笔记。交付：笔记。
- W16D2 — 目标：试验把虚拟设备通过 VFIO 直通（理论/准备）。任务：在文档中示例如何 bind 到 VFIO。交付：步骤草案。
- W16D3 — 目标：SR-IOV 概念（PF/VF）。任务：读 SR-IOV 文档并记录 driver 要点。交付：概念笔记。
- W16D4 — 目标：用户态驱动安全注意事项（IOMMU、DMA） 。任务：写一页注意事项。交付：文档。
- W16D5 — 目标：小 Demo：用用户态与内核态合作做 fast-path。任务：设计并记录实现思路。交付：设计文档草案。

Week 17 — 并发高级：RCU / lockless / refcount
- W17D1 — 目标：RCU 基本概念与读多写少场景。任务：阅读 RCU 文档。交付：简述 RCU 使用场景。
- W17D2 — 目标：用 rcu_read_lock / synchronize_rcu 做简单替换。任务：在驱动中改写一个读多写少的数据访问。交付：代码片段与行为对比。
- W17D3 — 目标：refcount 与生命周期管理。任务：检查常见对象的 refcount 实现并实验。交付：示例。
- W17D4 — 目标：无锁队列/环形 buffer 理解。任务：实现或阅读一个简单的 lock-free ring buffer。交付：注释版代码或小 demo。
- W17D5 — 目标：并发错误模式与诊断。任务：用 KCSAN/lockdep 做简单检测（若可用）。交付：检测日志。

Week 18 — 错误恢复、鲁棒性与生产化
- W18D1 — 目标：错误处理范式（probe 失败回滚）。任务：写一个 driver 的 probe 中的资源分配/回退示例。交付：代码片段。
- W18D2 — 目标：重入、防止重复 probe/unbind。任务：模拟重复 probe 情况并防护。交付：日志与修复。
- W18D3 — 目标：日志级别与运行时开关（dynamic_debug / tracepoints）。任务：在驱动中添加 tracepoints 并用 perf/trace-cmd 观测。交付：trace 输出。
- W18D4 — 目标：热插拔测试策略。任务：写脚本模拟多次插拔并检查泄露。交付：脚本与输出。
- W18D5 — 目标：编排与打包（DKMS 简介）。任务：写 basic DKMS 配置思路（若需要支持多内核）。交付：DKMS 配方草案。

Week 19 — 性能调优循环（测量→定位→优化）
- W19D1 — 目标：性能测量工具熟练（perf、bpftool、bpftrace）。任务：测一次驱动的 perf 采样。交付：perf 数据。
- W19D2 — 目标：生成火焰图并读懂 top hotspots。任务：生成 flamegraph 并识别可优化点。交付：hotspot 列表。
- W19D3 — 目标：优化一个热点（减少锁开销/内存拷贝）。任务：在驱动中做一次小改进并测量。交付：优化前后对比。
- W19D4 — 目标：回归测试（回归脚本）。任务：写回归脚本在优化后验证功能正确性。交付：回归脚本。
- W19D5 — 目标：把上述过程整理成模板（perf→flame→patch→test）。任务：写一页模板化流程。交付：流程模板。

Week 20 — 安全与可维护性
- W20D1 — 目标：驱动安全（输入验证 / 用户态数据检查）。任务：检查驱动的所有用户态入口并加防护。交付：修复补丁。
- W20D2 — 目标：最小权限原则（资源权限 / sysfs 权限）。任务：把 sysfs、device node 权限设置为合理值。交付：权限说明。
- W20D3 — 目标：代码风格与提交规范（Signed-off-by / commit message）。任务：运行 checkpatch 并改进提交信息。交付：规范补丁。
- W20D4 — 目标：维护性（文档/注释）。任务：补齐模块注释与 README。交付：更新后的文档。
- W20D5 — 目标：制定 bug report & patch template（内部/上游）。任务：写 template。交付：template 文件。

Week 21 — KUnit 进阶、CI 集成（本地）
- W21D1 — 目标：扩展 KUnit 测试覆盖更多逻辑。任务：为 driver 的边界条件写更完整测试。交付：KUnit 覆盖报告。
- W21D2 — 目标：在本地 CI（脚本）中集成构建与测试。任务：写 shell 阶段化脚本（build/test/cleanup）。交付：CI 脚本。
- W21D3 — 目标：内核构建缓存优化（ccache / build directory）。任务：配置并记录构建加速技巧。交付：经验笔记。
- W21D4 — 目标：在 QEMU 中做自动化测试（无交互）。任务：写一个自动化脚本在 QEMU guest 里执行你的测试。交付：自动化脚本。
- W21D5 — 目标：KUnit 用于回归保护。任务：运行改动前后测试验证。交付：对比结果。

Week 22 — 上游流程准备（format-patch / mailing lists）
- W22D1 — 目标：用 git format-patch 生成合规 patch。任务：写一个小修改并用 format-patch 导出。交付：patch 文件。
- W22D2 — 目标：学习 get_maintainer.pl / 寻找目标维护者。任务：运行 get_maintainer.pl 并收集要发送的邮件地址。交付：维护者列表。
- W22D3 — 目标：写一个清晰的 patch 描述与测试说明。任务：把你的 patch 写成便于 reviewers 验证的格式。交付：最终 patch 与说明。
- W22D4 — 目标：练习代码审查（自我/同伴 review）。任务：模拟审查并记录改动清单。交付：review notes。
- W22D5 — 目标：按 checkpatch 标准调整 patch 并准备提交。任务：运行 checkpatch 并修正。交付：合规 patch。

Week 23 — 最终项目实现（Phase 1：骨架 + 基本功能）
- W23D1 — 目标：选定最终项目（例如：虚拟块驱动 + PM + KUnit）。任务：写项目范围/接口与验收条件。交付：项目计划文档。
- W23D2 — 目标：实现项目骨架（模块/注册/主要 entry points）。任务：建仓并提交第一个 commit（骨架）。交付：骨架 commit。
- W23D3 — 目标：实现最小功能并写用户态 demo。任务：完成基本 I/O 路径。交付：demo 截图/日志。
- W23D4 — 目标：添加 PM support / runtime PM（若适用）。任务：实现并测试 suspend/resume。交付：PM 测试结果。
- W23D5 — 目标：补齐 KUnit / 基本回归测试。任务：写 2-3 个关键用例。交付：KUnit 结果。

Week 24 — 最终项目收尾（测试 / 上游准备 / 演示）
- W24D1 — 目标：性能/稳定性压力测试。任务：用 fio / stress-ng /自测脚本做连续测试。交付：压力测试报告。
- W24D2 — 目标：修复在测试中发现的问题并写 changelog。任务：修复 1-2 个 bug。交付：修复 patch。
- W24D3 — 目标：准备上游 patch 或内部 PR（格式、签名、测试说明）。任务：把所有补丁打包并写提交说明。交付：patch bundle。
- W24D4 — 目标：做一次演示（录像或 live demo）。任务：准备 demo 脚本并录制（或现场演示）。交付：演示视频或脚本。
- W24D5 — 目标：回顾/下一步规划（面试准备/简历素材）。任务：把所有产物整理为一个 README，列出你能讲清的 5 个设计点。交付：最终 repo + 自我复盘清单。

四：日常工作流 & 快速检查点（便于 1 小时节奏）
- 每日模板（1 小时内）：
  - 0–15 分钟：阅读文档/相关源码/例子（定位要点）。  
  - 15–55 分钟：编码/运行测试/复现（把任务拆成可 40 分钟完成的小目标）。  
  - 55–60 分钟：把产出（日志、截图、小结）写入当天笔记并 push（如果有 repo）。
- 每周检查点（周五）：提交本周 demo 到你的 repo，写 3 行“本周学到的/遇到的问题/下周计划”。

五：我可以立刻为你做的两件事（选择其一或都选）
1. 把上面 Day1~Day3 的 starter 文件（hello.c、minichar.c、Makefile、user_test.c、测试脚本）打包成一个可下载的 zip / GitHub gist（你会直接收到一个链接），或把它们整理成一个 Git 仓库（我可以把内容生成为一组可复制的文件片段）。  
2. 按照你希望的起始天（例如：明天开始 Day1），把“当天要完成的任务”做成可复用的 GitHub Issue 模板和一组 checklists，便于你每日打卡与我跟进。

我还需要问 2 个小问题以便把 starter 体验优化：
- 你本地使用的是哪个发行版/版本（例如 Ubuntu 22.04 / 24.04 / CentOS / Fedora）？我会据此给出更精确的安装命令。  
- 你会使用 QEMU（无真实硬件）还是你有一块测试板/机器可以用来插拔驱动？（若你用 QEMU，我会把 QEMU 启动命令与最小 rootfs 设置写得更详细）

告诉我你要我先做哪一件（生成 starter zip/gist / 生成 GitHub Issue 清单 / 直接把 Day1 的文件放入你的 repo —— 若要放入 repo 我会需要 repo 路径），我就立刻把文件/Issue 模板准备好。


